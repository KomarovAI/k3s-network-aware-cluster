apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-noise-reduction-pipeline
  namespace: logging
data:
  20-reduce-noise.conf: |
    filter {
      # === ШУМОДАВ 1: Drop health checks и liveness/readiness ===
      if [kubernetes][container][name] =~ /.*health.*|.*liveness.*|.*readiness.*/ {
        drop { }
      }
      
      # === ШУМОДАВ 2: Drop nginx/ingress успешные запросы ===
      if [kubernetes][labels][app] =~ /nginx|ingress/ {
        if [message] =~ /HTTP\/[12]\.[0-9]" [23][0-9][0-9]/ {
          drop { }
        }
      }
      
      # === ШУМОДАВ 3: Drop системные k8s события низкого уровня ===
      if [kubernetes][namespace] in ["kube-system", "kube-public", "kube-node-lease"] {
        # Оставляем только warn/error/fatal
        if [log][level] and [log][level] !~ /(?i)(warn|error|fatal|critical)/ {
          drop { }
        }
        # Drop по ключевым словам
        if [message] =~ /(?i)(successfully|completed|started|stopped|healthy)/ {
          drop { }
        }
      }
      
      # === ШУМОДАВ 4: Drop prometheus metrics scraping ===
      if [kubernetes][labels][app] =~ /prometheus/ {
        if [message] =~ /level=debug|GET \/metrics/ {
          drop { }
        }
      }
      
      # === ШУМОДАВ 5: Drop cert-manager успешные операции ===
      if [kubernetes][namespace] == "cert-manager" {
        if [message] =~ /certificate issued successfully|certificate is up to date/ {
          drop { }
        }
      }
      
      # === ОПТИМИЗАЦИЯ 1: Truncate очень длинные сообщения ===
      if [message] {
        ruby {
          code => '
            msg = event.get("message")
            if msg && msg.length > 16384
              event.set("message", msg[0, 16384] + "... [TRUNCATED]")
              event.set("[@metadata][truncated]", true)
            end
          '
        }
      }
      
      # === ОПТИМИЗАЦИЯ 2: Нормализация уровней логов ===
      if [log][level] {
        mutate {
          lowercase => [ "[log][level]" ]
        }
      }
      
      # Пытаемся извлечь level из message если не найден
      if ![log][level] {
        if [message] =~ /(?i)\b(error|err)\b/ {
          mutate { add_field => { "[log][level]" => "error" } }
        } else if [message] =~ /(?i)\b(warn|warning)\b/ {
          mutate { add_field => { "[log][level]" => "warn" } }
        } else if [message] =~ /(?i)\b(info|information)\b/ {
          mutate { add_field => { "[log][level]" => "info" } }
        } else if [message] =~ /(?i)\b(debug)\b/ {
          mutate { add_field => { "[log][level]" => "debug" } }
        }
      }
      
      # === ОПТИМИЗАЦИЯ 3: JSON parsing если возможно ===
      if [message] =~ /^\s*[\{\[]/ {
        json {
          source => "message"
          target => "parsed"
          skip_on_invalid_json => true
        }
        
        # Если удалось распарсить, перемещаем важные поля
        if [parsed] {
          if [parsed][level] and ![log][level] {
            mutate { add_field => { "[log][level]" => "%{[parsed][level]}" } }
          }
          if [parsed][timestamp] {
            date {
              match => [ "[parsed][timestamp]", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ" ]
              target => "@timestamp"
            }
          }
        }
      }
      
      # === ОПТИМИЗАЦИЯ 4: HTTP request parsing ===
      if [kubernetes][labels][app] =~ /nginx|ingress|web|api/ {
        grok {
          match => { "message" => "%{COMBINEDAPACHELOG}" }
          tag_on_failure => ["_grok_parse_failure_http"]
          add_field => { "[@metadata][is_http_log]" => "true" }
        }
      }
      
      # === ДЕДУПЛИКАЦИЯ (опционально, для очень шумных логов) ===
      # fingerprint {
      #   source => ["kubernetes.namespace", "kubernetes.pod.name", "kubernetes.container.name", "message"]
      #   target => "[@metadata][fingerprint]"
      #   method => "SHA256"
      # }
      # 
      # aggregate {
      #   task_id => "%{[@metadata][fingerprint]}"
      #   code => '
      #     map["count"] ||= 0
      #     map["count"] += 1
      #     map["first_seen"] ||= event.get("@timestamp")
      #     map["last_seen"] = event.get("@timestamp")
      #     map["message"] = event.get("message")
      #   '
      #   push_previous_map_as_event => true
      #   timeout => 300
      #   timeout_tags => ["deduplicated"]
      #   timeout_code => '
      #     event.set("message", map["message"])
      #     event.set("duplicate_count", map["count"])
      #     event.set("first_seen", map["first_seen"]) 
      #     event.set("last_seen", map["last_seen"])
      #   '
      # }
      
      # === ФИНАЛЬНАЯ ОЧИСТКА ===
      # Удаляем временные поля
      mutate {
        remove_field => [ "[parsed]", "[agent]", "[log][file][path]" ]
      }
    }